   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               	.global	Debug_SendByte
  13               	Debug_SendByte:
  14               	.LFB13:
  15               		.file 1 "debug.c"
   1:debug.c       **** /*
   2:debug.c       ****  *  debug.c
   3:debug.c       ****  *  DevBoardTest
   4:debug.c       ****  *
   5:debug.c       ****  *  Created by Joshua Schapiro on 12/20/11.
   6:debug.c       ****  *  Copyright 2011 Carnegie Mellon. All rights reserved.
   7:debug.c       ****  *
   8:debug.c       ****  */
   9:debug.c       **** 
  10:debug.c       **** #include "debug.h"
  11:debug.c       **** 
  12:debug.c       **** volatile uint8_t    DebugBuffer[100];
  13:debug.c       **** volatile uint16_t  	Debug_readLocation = 0;
  14:debug.c       **** volatile uint16_t   Debug_writeLocation = 0;
  15:debug.c       **** 
  16:debug.c       **** static FILE mystdout = FDEV_SETUP_STREAM (Debug_SendByte, NULL, _FDEV_SETUP_WRITE);
  17:debug.c       **** 
  18:debug.c       **** void Debug_Init(void){
  19:debug.c       **** 	PORTE.DIRSET = 0b00001000;			// tx line
  20:debug.c       **** 	PORTE.DIRCLR = 0b00000100;			// rx line
  21:debug.c       **** 	
  22:debug.c       **** 	USARTE0.CTRLC = USART_PMODE_DISABLED_gc | USART_CHSIZE_8BIT_gc ; 	    				
  23:debug.c       **** 	
  24:debug.c       **** 	USARTE0.BAUDCTRLA = 207 & 0xFF;								// 32mhz @9600
  25:debug.c       **** 	USARTE0.BAUDCTRLB = (0 << USART_BSCALE0_bp)|(207 >> 8);
  26:debug.c       **** 	
  27:debug.c       **** 	USARTE0.CTRLB |= USART_RXEN_bm;
  28:debug.c       **** 	USARTE0.CTRLB |= USART_TXEN_bm;
  29:debug.c       **** 	
  30:debug.c       **** 	USARTE0.CTRLA |= USART_RXCINTLVL_LO_gc;
  31:debug.c       **** 	
  32:debug.c       ****     stdout = &mystdout;
  33:debug.c       **** }
  34:debug.c       **** 
  35:debug.c       **** 
  36:debug.c       **** 
  37:debug.c       **** 
  38:debug.c       **** void Debug_SendByte(uint8_t data){
  16               		.loc 1 38 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22               	.LVL0:
  23               	.L3:
  39:debug.c       **** 	while(!(USARTE0.STATUS & USART_DREIF_bm));
  24               		.loc 1 39 0 discriminator 1
  25 0000 9091 A10A 		lds r25,2721
  26 0004 95FF      		sbrs r25,5
  27 0006 00C0      		rjmp .L3
  40:debug.c       **** 	USARTE0.DATA = data;	
  28               		.loc 1 40 0
  29 0008 8093 A00A 		sts 2720,r24
  30 000c 0895      		ret
  31               		.cfi_endproc
  32               	.LFE13:
  34               	.global	Debug_Init
  36               	Debug_Init:
  37               	.LFB12:
  18:debug.c       **** void Debug_Init(void){
  38               		.loc 1 18 0
  39               		.cfi_startproc
  40               	/* prologue: function */
  41               	/* frame size = 0 */
  42               	/* stack size = 0 */
  43               	.L__stack_usage = 0
  19:debug.c       **** 	PORTE.DIRSET = 0b00001000;			// tx line
  44               		.loc 1 19 0
  45 000e E0E8      		ldi r30,lo8(-128)
  46 0010 F6E0      		ldi r31,lo8(6)
  47 0012 88E0      		ldi r24,lo8(8)
  48 0014 8183      		std Z+1,r24
  20:debug.c       **** 	PORTE.DIRCLR = 0b00000100;			// rx line
  49               		.loc 1 20 0
  50 0016 84E0      		ldi r24,lo8(4)
  51 0018 8283      		std Z+2,r24
  22:debug.c       **** 	USARTE0.CTRLC = USART_PMODE_DISABLED_gc | USART_CHSIZE_8BIT_gc ; 	    				
  52               		.loc 1 22 0
  53 001a E0EA      		ldi r30,lo8(-96)
  54 001c FAE0      		ldi r31,lo8(10)
  55 001e 83E0      		ldi r24,lo8(3)
  56 0020 8583      		std Z+5,r24
  24:debug.c       **** 	USARTE0.BAUDCTRLA = 207 & 0xFF;								// 32mhz @9600
  57               		.loc 1 24 0
  58 0022 8FEC      		ldi r24,lo8(-49)
  59 0024 8683      		std Z+6,r24
  25:debug.c       **** 	USARTE0.BAUDCTRLB = (0 << USART_BSCALE0_bp)|(207 >> 8);
  60               		.loc 1 25 0
  61 0026 1782      		std Z+7,__zero_reg__
  27:debug.c       **** 	USARTE0.CTRLB |= USART_RXEN_bm;
  62               		.loc 1 27 0
  63 0028 8481      		ldd r24,Z+4
  64 002a 8061      		ori r24,lo8(16)
  65 002c 8483      		std Z+4,r24
  28:debug.c       **** 	USARTE0.CTRLB |= USART_TXEN_bm;
  66               		.loc 1 28 0
  67 002e 8481      		ldd r24,Z+4
  68 0030 8860      		ori r24,lo8(8)
  69 0032 8483      		std Z+4,r24
  30:debug.c       **** 	USARTE0.CTRLA |= USART_RXCINTLVL_LO_gc;
  70               		.loc 1 30 0
  71 0034 8381      		ldd r24,Z+3
  72 0036 8061      		ori r24,lo8(16)
  73 0038 8383      		std Z+3,r24
  32:debug.c       ****     stdout = &mystdout;
  74               		.loc 1 32 0
  75 003a 80E0      		ldi r24,lo8(mystdout)
  76 003c 90E0      		ldi r25,hi8(mystdout)
  77 003e 8093 0000 		sts __iob+2,r24
  78 0042 9093 0000 		sts __iob+2+1,r25
  79 0046 0895      		ret
  80               		.cfi_endproc
  81               	.LFE12:
  83               	.global	Debug_CharReadyToRead
  85               	Debug_CharReadyToRead:
  86               	.LFB14:
  41:debug.c       **** }
  42:debug.c       **** 
  43:debug.c       **** bool Debug_CharReadyToRead(void){
  87               		.loc 1 43 0
  88               		.cfi_startproc
  89               	/* prologue: function */
  90               	/* frame size = 0 */
  91               	/* stack size = 0 */
  92               	.L__stack_usage = 0
  44:debug.c       **** 	if(Debug_writeLocation == Debug_readLocation){
  93               		.loc 1 44 0
  94 0048 4091 0000 		lds r20,Debug_writeLocation
  95 004c 5091 0000 		lds r21,Debug_writeLocation+1
  96 0050 2091 0000 		lds r18,Debug_readLocation
  97 0054 3091 0000 		lds r19,Debug_readLocation+1
  98 0058 81E0      		ldi r24,lo8(1)
  99 005a 4217      		cp r20,r18
 100 005c 5307      		cpc r21,r19
 101 005e 01F4      		brne .L7
 102 0060 80E0      		ldi r24,0
 103               	.L7:
  45:debug.c       **** 		return false;  
  46:debug.c       **** 	} else { 
  47:debug.c       **** 		return true;
  48:debug.c       **** 	}
  49:debug.c       **** }
 104               		.loc 1 49 0
 105 0062 0895      		ret
 106               		.cfi_endproc
 107               	.LFE14:
 109               	.global	Debug_GetByte
 111               	Debug_GetByte:
 112               	.LFB15:
  50:debug.c       **** 
  51:debug.c       **** 
  52:debug.c       **** uint8_t Debug_GetByte(bool blocking){
 113               		.loc 1 52 0
 114               		.cfi_startproc
 115               	.LVL1:
 116               	/* prologue: function */
 117               	/* frame size = 0 */
 118               	/* stack size = 0 */
 119               	.L__stack_usage = 0
  53:debug.c       **** 	if(blocking){
 120               		.loc 1 53 0
 121 0064 8111      		cpse r24,__zero_reg__
 122 0066 00C0      		rjmp .L13
 123               	.LVL2:
 124               	.L12:
  54:debug.c       **** 		while(!Debug_CharReadyToRead());
  55:debug.c       **** 	}
  56:debug.c       **** 	
  57:debug.c       **** 	uint8_t tmp = DebugBuffer[Debug_readLocation];
 125               		.loc 1 57 0
 126 0068 E091 0000 		lds r30,Debug_readLocation
 127 006c F091 0000 		lds r31,Debug_readLocation+1
 128 0070 E050      		subi r30,lo8(-(DebugBuffer))
 129 0072 F040      		sbci r31,hi8(-(DebugBuffer))
 130 0074 8081      		ld r24,Z
 131               	.LVL3:
  58:debug.c       **** 	Debug_readLocation++;
 132               		.loc 1 58 0
 133 0076 2091 0000 		lds r18,Debug_readLocation
 134 007a 3091 0000 		lds r19,Debug_readLocation+1
 135 007e 2F5F      		subi r18,-1
 136 0080 3F4F      		sbci r19,-1
 137 0082 2093 0000 		sts Debug_readLocation,r18
 138 0086 3093 0000 		sts Debug_readLocation+1,r19
  59:debug.c       **** 	if(Debug_readLocation >= 100){
 139               		.loc 1 59 0
 140 008a 2091 0000 		lds r18,Debug_readLocation
 141 008e 3091 0000 		lds r19,Debug_readLocation+1
 142 0092 2436      		cpi r18,100
 143 0094 3105      		cpc r19,__zero_reg__
 144 0096 00F4      		brsh .L10
 145 0098 0895      		ret
 146               	.LVL4:
 147               	.L13:
  54:debug.c       **** 		while(!Debug_CharReadyToRead());
 148               		.loc 1 54 0
 149 009a 0E94 0000 		call Debug_CharReadyToRead
 150               	.LVL5:
 151 009e 8823      		tst r24
 152 00a0 01F0      		breq .L13
 153 00a2 00C0      		rjmp .L12
 154               	.LVL6:
 155               	.L10:
  60:debug.c       **** 		Debug_readLocation=0;
 156               		.loc 1 60 0
 157 00a4 1092 0000 		sts Debug_readLocation,__zero_reg__
 158 00a8 1092 0000 		sts Debug_readLocation+1,__zero_reg__
  61:debug.c       **** 	}
  62:debug.c       **** 	return tmp;
  63:debug.c       **** }
 159               		.loc 1 63 0
 160 00ac 0895      		ret
 161               		.cfi_endproc
 162               	.LFE15:
 164               	.global	__vector_58
 166               	__vector_58:
 167               	.LFB16:
  64:debug.c       **** 
  65:debug.c       **** ISR(USARTE0_RXC_vect){
 168               		.loc 1 65 0
 169               		.cfi_startproc
 170 00ae 1F92      		push r1
 171               	.LCFI0:
 172               		.cfi_def_cfa_offset 3
 173               		.cfi_offset 1, -2
 174 00b0 0F92      		push r0
 175               	.LCFI1:
 176               		.cfi_def_cfa_offset 4
 177               		.cfi_offset 0, -3
 178 00b2 0FB6      		in r0,__SREG__
 179 00b4 0F92      		push r0
 180 00b6 1124      		clr __zero_reg__
 181 00b8 8F93      		push r24
 182               	.LCFI2:
 183               		.cfi_def_cfa_offset 5
 184               		.cfi_offset 24, -4
 185 00ba 9F93      		push r25
 186               	.LCFI3:
 187               		.cfi_def_cfa_offset 6
 188               		.cfi_offset 25, -5
 189 00bc EF93      		push r30
 190               	.LCFI4:
 191               		.cfi_def_cfa_offset 7
 192               		.cfi_offset 30, -6
 193 00be FF93      		push r31
 194               	.LCFI5:
 195               		.cfi_def_cfa_offset 8
 196               		.cfi_offset 31, -7
 197               	/* prologue: Signal */
 198               	/* frame size = 0 */
 199               	/* stack size = 7 */
 200               	.L__stack_usage = 7
  66:debug.c       **** 	DebugBuffer[Debug_writeLocation] = USARTE0.DATA;
 201               		.loc 1 66 0
 202 00c0 E091 0000 		lds r30,Debug_writeLocation
 203 00c4 F091 0000 		lds r31,Debug_writeLocation+1
 204 00c8 8091 A00A 		lds r24,2720
 205 00cc E050      		subi r30,lo8(-(DebugBuffer))
 206 00ce F040      		sbci r31,hi8(-(DebugBuffer))
 207 00d0 8083      		st Z,r24
  67:debug.c       **** 	Debug_writeLocation++;
 208               		.loc 1 67 0
 209 00d2 8091 0000 		lds r24,Debug_writeLocation
 210 00d6 9091 0000 		lds r25,Debug_writeLocation+1
 211 00da 0196      		adiw r24,1
 212 00dc 8093 0000 		sts Debug_writeLocation,r24
 213 00e0 9093 0000 		sts Debug_writeLocation+1,r25
  68:debug.c       **** 	if(Debug_writeLocation >= 100){
 214               		.loc 1 68 0
 215 00e4 8091 0000 		lds r24,Debug_writeLocation
 216 00e8 9091 0000 		lds r25,Debug_writeLocation+1
 217 00ec 8436      		cpi r24,100
 218 00ee 9105      		cpc r25,__zero_reg__
 219 00f0 00F0      		brlo .L14
  69:debug.c       **** 		Debug_writeLocation = 0;
 220               		.loc 1 69 0
 221 00f2 1092 0000 		sts Debug_writeLocation,__zero_reg__
 222 00f6 1092 0000 		sts Debug_writeLocation+1,__zero_reg__
 223               	.L14:
 224               	/* epilogue start */
  70:debug.c       **** 	}
  71:debug.c       **** }...
 225               		.loc 1 71 0
 226 00fa FF91      		pop r31
 227 00fc EF91      		pop r30
 228 00fe 9F91      		pop r25
 229 0100 8F91      		pop r24
 230 0102 0F90      		pop r0
 231 0104 0FBE      		out __SREG__,r0
 232 0106 0F90      		pop r0
 233 0108 1F90      		pop r1
 234 010a 1895      		reti
 235               		.cfi_endproc
 236               	.LFE16:
 238               		.section	.rodata.str1.1,"aMS",@progbits,1
 239               	.LC0:
 240 0000 4849 5420 		.string	"HIT END\r"
 240      454E 440D 
 240      00
 241               		.text
 242               	.global	__vector_20
 244               	__vector_20:
 245               	.LFB18:
 246               		.file 2 "main.c"
   1:main.c        **** 
   2:main.c        **** 
   3:main.c        **** #include "avr_compiler.h"
   4:main.c        **** #include <stdio.h>
   5:main.c        **** #include "string.h"
   6:main.c        **** #include "main.h"
   7:main.c        **** #include "debug.c"
   8:main.c        **** 
   9:main.c        **** #define usb_pin_bm  (1 << 0)
  10:main.c        **** #define cam_pin_bm (1 << 1)
  11:main.c        **** #define outputPORT  PORTD
  12:main.c        **** 
  13:main.c        **** void Clock_Init(void);
  14:main.c        **** void Interrupts_Init(void);
  15:main.c        **** void CCPWrite( volatile uint8_t * address, uint8_t value );
  16:main.c        **** 
  17:main.c        **** 
  18:main.c        **** uint8_t command = 0;
  19:main.c        **** volatile uint16_t servoCurrent;
  20:main.c        **** volatile uint16_t servoSpeedCounter = 0;
  21:main.c        **** volatile uint8_t currentCapCounter = 0;
  22:main.c        **** volatile bool runServo;
  23:main.c        **** #define currentMax  150
  24:main.c        **** #define currentCapThreshold   5
  25:main.c        **** 
  26:main.c        **** int main(void){
  27:main.c        **** 
  28:main.c        **** 
  29:main.c        ****     Clock_Init();
  30:main.c        ****     Debug_Init();
  31:main.c        ****     printf("Starting up!\r");
  32:main.c        **** 
  33:main.c        ****     // 100hz for servo upkeep
  34:main.c        ****     TCC1.PER = 49;
  35:main.c        ****     TCC1.CTRLA = TC_CLKSEL_DIV64_gc;
  36:main.c        ****     TCC1.INTCTRLA = TC_CCAINTLVL_LO_gc;
  37:main.c        **** 
  38:main.c        **** 
  39:main.c        ****     ADCA.CH1.CTRL = ADC_CH_INPUTMODE_SINGLEENDED_gc;    // set input mode
  40:main.c        ****     ADCA.CH1.MUXCTRL = ADC_CH_MUXPOS_PIN1_gc;           // set mux to read channel 0, pin A1
  41:main.c        **** 
  42:main.c        **** 
  43:main.c        ****     ADCA.PRESCALER = (ADCA.PRESCALER & (~ADC_PRESCALER_gm)) | ADC_PRESCALER_DIV16_gc;
  44:main.c        **** 
  45:main.c        ****     ADCA.REFCTRL = ADC_REFSEL_INT1V_gc;
  46:main.c        ****     ADCA.EVCTRL = 0;
  47:main.c        ****     ADCA.CTRLB = 0;
  48:main.c        ****     ADCA.CTRLA = ADC_ENABLE_bm;
  49:main.c        **** 
  50:main.c        **** 
  51:main.c        **** 
  52:main.c        ****     PORTC.DIRSET = (1 << 0);
  53:main.c        ****     PORTC.OUTCLR = (1 << 0);
  54:main.c        **** 
  55:main.c        ****     TCC0.CTRLA = 0x05;				//set TC_CLK to CLK/64 (500k)
  56:main.c        ****     TCC0.CTRLB = TC0_CCAEN_bm | TC0_WGMODE0_bm | TC0_WGMODE1_bm;       //Enable OC A,B,C&D.  Set to
  57:main.c        ****     TCC0.PER = 10000;				// (500k / 10k = 50 hz)  (500 bits per ms)
  58:main.c        ****     TCC0.CCA = 750;
  59:main.c        **** 
  60:main.c        **** 
  61:main.c        ****     currentPORT.DIRSET = currentCS_bm |  currentCLK_bm | currentMOSI_bm;
  62:main.c        ****     currentPORT.OUTSET = currentCS_bm;
  63:main.c        **** 
  64:main.c        ****     currentSPI.CTRL = SPI_ENABLE_bm
  65:main.c        ****                        | SPI_MASTER_bm
  66:main.c        ****                        | SPI_MODE_0_gc
  67:main.c        ****                        | SPI_PRESCALER_DIV128_gc;
  68:main.c        **** 
  69:main.c        **** 
  70:main.c        **** 
  71:main.c        **** 
  72:main.c        ****     outputPORT.DIRSET = usb_pin_bm | cam_pin_bm;
  73:main.c        ****     outputPORT.OUTCLR = usb_pin_bm | cam_pin_bm;
  74:main.c        **** 
  75:main.c        **** 
  76:main.c        ****     _delay_ms(2000);
  77:main.c        ****     Interrupts_Init();
  78:main.c        **** 
  79:main.c        **** /*    uint16_t a, b;
  80:main.c        ****     while(true){
  81:main.c        ****         a 	= Current_Read(0xA0);
  82:main.c        ****         printf("%u\r",a);
  83:main.c        ****         _delay_ms(100);
  84:main.c        ****     }
  85:main.c        **** */
  86:main.c        **** 
  87:main.c        ****     while(true){
  88:main.c        ****     
  89:main.c        ****         
  90:main.c        ****         _delay_ms(10);
  91:main.c        ****         if(Debug_CharReadyToRead()){
  92:main.c        ****             command = Debug_GetByte(false);
  93:main.c        ****             switch (command) {
  94:main.c        ****                 case 'C':   // turn camera off
  95:main.c        ****                     outputPORT.OUTSET = cam_pin_bm;
  96:main.c        ****                     break;
  97:main.c        ****                 case 'c':   // turn camera on
  98:main.c        ****                     outputPORT.OUTCLR = cam_pin_bm;
  99:main.c        ****                     break;
 100:main.c        ****                 case 'U':       //turn usb off
 101:main.c        ****                     outputPORT.OUTSET = usb_pin_bm;
 102:main.c        ****                     break;
 103:main.c        ****                 case 'u':       // turn usb on
 104:main.c        ****                     outputPORT.OUTCLR = usb_pin_bm;
 105:main.c        ****                     break;
 106:main.c        ****                 case 's':
 107:main.c        ****                     currentCapCounter = 0;
 108:main.c        ****                     runServo = true;
 109:main.c        ****                     printf("pressing button\r");
 110:main.c        ****                     break;
 111:main.c        ****                 default:
 112:main.c        ****                     break;
 113:main.c        ****             }
 114:main.c        ****         }
 115:main.c        ****         
 116:main.c        ****     }
 117:main.c        **** }
 118:main.c        **** 
 119:main.c        **** ISR(TCC1_OVF_vect){
 247               		.loc 2 119 0
 248               		.cfi_startproc
 249 010c 1F92      		push r1
 250               	.LCFI6:
 251               		.cfi_def_cfa_offset 3
 252               		.cfi_offset 1, -2
 253 010e 0F92      		push r0
 254               	.LCFI7:
 255               		.cfi_def_cfa_offset 4
 256               		.cfi_offset 0, -3
 257 0110 0FB6      		in r0,__SREG__
 258 0112 0F92      		push r0
 259 0114 1124      		clr __zero_reg__
 260 0116 2F93      		push r18
 261               	.LCFI8:
 262               		.cfi_def_cfa_offset 5
 263               		.cfi_offset 18, -4
 264 0118 3F93      		push r19
 265               	.LCFI9:
 266               		.cfi_def_cfa_offset 6
 267               		.cfi_offset 19, -5
 268 011a 4F93      		push r20
 269               	.LCFI10:
 270               		.cfi_def_cfa_offset 7
 271               		.cfi_offset 20, -6
 272 011c 5F93      		push r21
 273               	.LCFI11:
 274               		.cfi_def_cfa_offset 8
 275               		.cfi_offset 21, -7
 276 011e 6F93      		push r22
 277               	.LCFI12:
 278               		.cfi_def_cfa_offset 9
 279               		.cfi_offset 22, -8
 280 0120 7F93      		push r23
 281               	.LCFI13:
 282               		.cfi_def_cfa_offset 10
 283               		.cfi_offset 23, -9
 284 0122 8F93      		push r24
 285               	.LCFI14:
 286               		.cfi_def_cfa_offset 11
 287               		.cfi_offset 24, -10
 288 0124 9F93      		push r25
 289               	.LCFI15:
 290               		.cfi_def_cfa_offset 12
 291               		.cfi_offset 25, -11
 292 0126 AF93      		push r26
 293               	.LCFI16:
 294               		.cfi_def_cfa_offset 13
 295               		.cfi_offset 26, -12
 296 0128 BF93      		push r27
 297               	.LCFI17:
 298               		.cfi_def_cfa_offset 14
 299               		.cfi_offset 27, -13
 300 012a EF93      		push r30
 301               	.LCFI18:
 302               		.cfi_def_cfa_offset 15
 303               		.cfi_offset 30, -14
 304 012c FF93      		push r31
 305               	.LCFI19:
 306               		.cfi_def_cfa_offset 16
 307               		.cfi_offset 31, -15
 308               	/* prologue: Signal */
 309               	/* frame size = 0 */
 310               	/* stack size = 15 */
 311               	.L__stack_usage = 15
 120:main.c        **** 
 121:main.c        **** 
 122:main.c        **** 
 123:main.c        ****     if(runServo){
 312               		.loc 2 123 0
 313 012e 8091 0000 		lds r24,runServo
 314 0132 8823      		tst r24
 315 0134 01F0      		breq .L16
 124:main.c        **** 
 125:main.c        ****         servoSpeedCounter++;
 316               		.loc 2 125 0
 317 0136 8091 0000 		lds r24,servoSpeedCounter
 318 013a 9091 0000 		lds r25,servoSpeedCounter+1
 319 013e 0196      		adiw r24,1
 320 0140 8093 0000 		sts servoSpeedCounter,r24
 321 0144 9093 0000 		sts servoSpeedCounter+1,r25
 126:main.c        ****         if(servoSpeedCounter > 50){
 322               		.loc 2 126 0
 323 0148 8091 0000 		lds r24,servoSpeedCounter
 324 014c 9091 0000 		lds r25,servoSpeedCounter+1
 325 0150 C397      		sbiw r24,51
 326 0152 00F0      		brlo .L16
 127:main.c        ****             servoSpeedCounter = 0;
 327               		.loc 2 127 0
 328 0154 1092 0000 		sts servoSpeedCounter,__zero_reg__
 329 0158 1092 0000 		sts servoSpeedCounter+1,__zero_reg__
 128:main.c        **** 
 129:main.c        **** 
 130:main.c        **** /*            servoCurrent = Current_Read(0xA0);
 131:main.c        ****             //printf("%u\r",servoCurrent);
 132:main.c        ****             if(servoCurrent > currentMax){
 133:main.c        ****                 currentCapCounter++;
 134:main.c        ****                 if(currentCapCounter > currentCapThreshold){
 135:main.c        ****                     currentCapCounter = 0;
 136:main.c        ****                     printf("STOP!\r");
 137:main.c        ****                     runServo = false;
 138:main.c        ****                     TCC0.CCA = 750;
 139:main.c        ****                 }
 140:main.c        ****                 //printf("%u\r",servoCurrent);
 141:main.c        ****             } else {
 142:main.c        ****                 currentCapCounter = 0;
 143:main.c        ****             }
 144:main.c        **** */
 145:main.c        **** 
 146:main.c        **** 
 147:main.c        ****             if (TCC0.CCA > 450) {
 330               		.loc 2 147 0
 331 015c 8091 2808 		lds r24,2088
 332 0160 9091 2908 		lds r25,2088+1
 333 0164 833C      		cpi r24,-61
 334 0166 9140      		sbci r25,1
 335 0168 00F0      		brlo .L20
 148:main.c        ****                 TCC0.CCA--;
 336               		.loc 2 148 0
 337 016a 8091 2808 		lds r24,2088
 338 016e 9091 2908 		lds r25,2088+1
 339 0172 0197      		sbiw r24,1
 340 0174 8093 2808 		sts 2088,r24
 341 0178 9093 2908 		sts 2088+1,r25
 342 017c 00C0      		rjmp .L16
 343               	.L20:
 149:main.c        ****             } else {
 150:main.c        ****                 printf("HIT END\r");
 344               		.loc 2 150 0
 345 017e 80E0      		ldi r24,lo8(.LC0)
 346 0180 90E0      		ldi r25,hi8(.LC0)
 347 0182 9F93      		push r25
 348               	.LCFI20:
 349               		.cfi_def_cfa_offset 17
 350 0184 8F93      		push r24
 351               	.LCFI21:
 352               		.cfi_def_cfa_offset 18
 353 0186 0E94 0000 		call printf
 354               	.LVL7:
 151:main.c        ****                 runServo = false;
 355               		.loc 2 151 0
 356 018a 1092 0000 		sts runServo,__zero_reg__
 152:main.c        ****                 TCC0.CCA = 750;
 357               		.loc 2 152 0
 358 018e 8EEE      		ldi r24,lo8(-18)
 359 0190 92E0      		ldi r25,lo8(2)
 360 0192 8093 2808 		sts 2088,r24
 361 0196 9093 2908 		sts 2088+1,r25
 362 019a 0F90      		pop __tmp_reg__
 363 019c 0F90      		pop __tmp_reg__
 364               	.LCFI22:
 365               		.cfi_def_cfa_offset 16
 366               	.L16:
 367               	/* epilogue start */
 153:main.c        ****             }
 154:main.c        ****         }
 155:main.c        **** 
 156:main.c        ****     }
 157:main.c        **** }
 368               		.loc 2 157 0
 369 019e FF91      		pop r31
 370 01a0 EF91      		pop r30
 371 01a2 BF91      		pop r27
 372 01a4 AF91      		pop r26
 373 01a6 9F91      		pop r25
 374 01a8 8F91      		pop r24
 375 01aa 7F91      		pop r23
 376 01ac 6F91      		pop r22
 377 01ae 5F91      		pop r21
 378 01b0 4F91      		pop r20
 379 01b2 3F91      		pop r19
 380 01b4 2F91      		pop r18
 381 01b6 0F90      		pop r0
 382 01b8 0FBE      		out __SREG__,r0
 383 01ba 0F90      		pop r0
 384 01bc 1F90      		pop r1
 385 01be 1895      		reti
 386               		.cfi_endproc
 387               	.LFE18:
 389               	.global	Interrupts_Init
 391               	Interrupts_Init:
 392               	.LFB20:
 158:main.c        **** 
 159:main.c        **** void Clock_Init(void){
 160:main.c        **** 	OSC.CTRL |= OSC_RC32MEN_bm;                     // turn on 32MHz internal RC oscillator
 161:main.c        **** 	while(!(OSC.STATUS & OSC_RC32MRDY_bm));         // wait for it to be ready
 162:main.c        **** 	CCPWrite( &CLK.CTRL, CLK_SCLKSEL_RC32M_gc);     // change from 2MHz to 32MHz
 163:main.c        **** }
 164:main.c        **** 
 165:main.c        **** void Interrupts_Init(void){
 393               		.loc 2 165 0
 394               		.cfi_startproc
 395               	/* prologue: function */
 396               	/* frame size = 0 */
 397               	/* stack size = 0 */
 398               	.L__stack_usage = 0
 166:main.c        **** 	
 167:main.c        **** 	PMIC.CTRL |= PMIC_LOLVLEN_bm;
 399               		.loc 2 167 0
 400 01c0 E0EA      		ldi r30,lo8(-96)
 401 01c2 F0E0      		ldi r31,0
 402 01c4 8281      		ldd r24,Z+2
 403 01c6 8160      		ori r24,lo8(1)
 404 01c8 8283      		std Z+2,r24
 168:main.c        **** 	sei();
 405               		.loc 2 168 0
 406               	/* #APP */
 407               	 ;  168 "main.c" 1
 408 01ca 7894      		sei
 409               	 ;  0 "" 2
 410               	/* #NOAPP */
 411 01cc 0895      		ret
 412               		.cfi_endproc
 413               	.LFE20:
 415               	.global	Current_Read
 417               	Current_Read:
 418               	.LFB21:
 169:main.c        **** 	
 170:main.c        **** }
 171:main.c        **** 
 172:main.c        **** uint16_t Current_Read(uint8_t channel){
 419               		.loc 2 172 0
 420               		.cfi_startproc
 421               	.LVL8:
 422               	/* prologue: function */
 423               	/* frame size = 0 */
 424               	/* stack size = 0 */
 425               	.L__stack_usage = 0
 173:main.c        ****     uint16_t hi, lo;
 174:main.c        **** 
 175:main.c        ****     currentPORT.OUTCLR = currentCLK_bm;
 426               		.loc 2 175 0
 427 01ce 90E8      		ldi r25,lo8(-128)
 428 01d0 9093 4606 		sts 1606,r25
 176:main.c        ****     currentPORT.OUTCLR = currentCS_bm;
 429               		.loc 2 176 0
 430 01d4 90E1      		ldi r25,lo8(16)
 431 01d6 9093 4606 		sts 1606,r25
 177:main.c        **** 
 178:main.c        ****     currentSPI.DATA = 1;
 432               		.loc 2 178 0
 433 01da 91E0      		ldi r25,lo8(1)
 434 01dc 9093 C308 		sts 2243,r25
 435               	.L24:
 179:main.c        ****     while(!(currentSPI.STATUS & SPI_IF_bm));
 436               		.loc 2 179 0 discriminator 1
 437 01e0 9091 C208 		lds r25,2242
 438 01e4 97FF      		sbrs r25,7
 439 01e6 00C0      		rjmp .L24
 180:main.c        **** 
 181:main.c        ****     currentSPI.DATA = channel;
 440               		.loc 2 181 0
 441 01e8 8093 C308 		sts 2243,r24
 442               	.LVL9:
 443               	.L26:
 182:main.c        ****     while(!(currentSPI.STATUS & SPI_IF_bm));
 444               		.loc 2 182 0 discriminator 1
 445 01ec 8091 C208 		lds r24,2242
 446 01f0 87FF      		sbrs r24,7
 447 01f2 00C0      		rjmp .L26
 183:main.c        ****     hi = (currentSPI.DATA & 0b0001111);
 448               		.loc 2 183 0
 449 01f4 8091 C308 		lds r24,2243
 450 01f8 8F70      		andi r24,lo8(15)
 451 01fa 90E0      		ldi r25,0
 452               	.LVL10:
 184:main.c        **** 
 185:main.c        ****     currentSPI.DATA = 0;
 453               		.loc 2 185 0
 454 01fc 1092 C308 		sts 2243,__zero_reg__
 455               	.LVL11:
 456               	.L28:
 186:main.c        ****     while(!(currentSPI.STATUS & SPI_IF_bm));
 457               		.loc 2 186 0 discriminator 1
 458 0200 2091 C208 		lds r18,2242
 459 0204 27FF      		sbrs r18,7
 460 0206 00C0      		rjmp .L28
 187:main.c        ****     lo = currentSPI.DATA;
 461               		.loc 2 187 0
 462 0208 2091 C308 		lds r18,2243
 463               	.LVL12:
 188:main.c        **** 
 189:main.c        ****     currentPORT.OUTSET = currentCS_bm;
 464               		.loc 2 189 0
 465 020c 30E1      		ldi r19,lo8(16)
 466 020e 3093 4506 		sts 1605,r19
 190:main.c        **** 
 191:main.c        ****     return (lo + (hi << 8));
 467               		.loc 2 191 0
 468 0212 982F      		mov r25,r24
 469 0214 8827      		clr r24
 470               	.LVL13:
 192:main.c        **** }
 471               		.loc 2 192 0
 472 0216 820F      		add r24,r18
 473 0218 911D      		adc r25,__zero_reg__
 474 021a 0895      		ret
 475               		.cfi_endproc
 476               	.LFE21:
 478               	.global	CCPWrite
 480               	CCPWrite:
 481               	.LFB22:
 193:main.c        **** 
 194:main.c        **** 
 195:main.c        **** // From Application Note AVR1003
 196:main.c        **** // Used to slow down clock in disk_initialize()
 197:main.c        **** void CCPWrite( volatile uint8_t * address, uint8_t value ) {
 482               		.loc 2 197 0
 483               		.cfi_startproc
 484               	.LVL14:
 485 021c 0F93      		push r16
 486               	.LCFI23:
 487               		.cfi_def_cfa_offset 3
 488               		.cfi_offset 16, -2
 489 021e CF93      		push r28
 490               	.LCFI24:
 491               		.cfi_def_cfa_offset 4
 492               		.cfi_offset 28, -3
 493 0220 DF93      		push r29
 494               	.LCFI25:
 495               		.cfi_def_cfa_offset 5
 496               		.cfi_offset 29, -4
 497 0222 1F92      		push __zero_reg__
 498               	.LCFI26:
 499               		.cfi_def_cfa_offset 6
 500 0224 CDB7      		in r28,__SP_L__
 501 0226 DEB7      		in r29,__SP_H__
 502               	.LCFI27:
 503               		.cfi_def_cfa_register 28
 504               	/* prologue: function */
 505               	/* frame size = 1 */
 506               	/* stack size = 4 */
 507               	.L__stack_usage = 4
 198:main.c        ****     uint8_t volatile saved_sreg = SREG;
 508               		.loc 2 198 0
 509 0228 2FB7      		in r18,__SREG__
 510 022a 2983      		std Y+1,r18
 199:main.c        ****     cli();
 511               		.loc 2 199 0
 512               	/* #APP */
 513               	 ;  199 "main.c" 1
 514 022c F894      		cli
 515               	 ;  0 "" 2
 516               	.LVL15:
 200:main.c        ****     
 201:main.c        **** #ifdef __ICCAVR__
 202:main.c        **** 	asm("movw r30, r16");
 203:main.c        **** #ifdef RAMPZ
 204:main.c        **** 	RAMPZ = 0;
 205:main.c        **** #endif
 206:main.c        **** 	asm("ldi  r16,  0xD8 \n"
 207:main.c        **** 	    "out  0x34, r16  \n"
 208:main.c        **** #if (__MEMORY_MODEL__ == 1)
 209:main.c        **** 	    "st     Z,  r17  \n");
 210:main.c        **** #elif (__MEMORY_MODEL__ == 2)
 211:main.c        ****     "st     Z,  r18  \n");
 212:main.c        **** #else /* (__MEMORY_MODEL__ == 3) || (__MEMORY_MODEL__ == 5) */
 213:main.c        ****     "st     Z,  r19  \n");
 214:main.c        **** #endif /* __MEMORY_MODEL__ */
 215:main.c        ****     
 216:main.c        **** #elif defined __GNUC__
 217:main.c        **** 	volatile uint8_t * tmpAddr = address;
 218:main.c        **** #ifdef RAMPZ
 219:main.c        **** 	RAMPZ = 0;
 517               		.loc 2 219 0
 518               	/* #NOAPP */
 519 022e 1BBE      		out 0x3b,__zero_reg__
 220:main.c        **** #endif
 221:main.c        **** 	asm volatile(
 520               		.loc 2 221 0
 521               	/* #APP */
 522               	 ;  221 "main.c" 1
 523 0230 FC01      		movw r30,  r24
 524 0232 08ED      		ldi  r16,  216
 525 0234 04BF      		out   52, r16
 526 0236 6083      		st     Z,  r22
 527               		
 528               	 ;  0 "" 2
 222:main.c        ****                  "movw r30,  %0"	      "\n\t"
 223:main.c        ****                  "ldi  r16,  %2"	      "\n\t"
 224:main.c        ****                  "out   %3, r16"	      "\n\t"
 225:main.c        ****                  "st     Z,  %1"       "\n\t"
 226:main.c        ****                  :
 227:main.c        ****                  : "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)
 228:main.c        ****                  : "r16", "r30", "r31"
 229:main.c        ****                  );
 230:main.c        ****     
 231:main.c        **** #endif
 232:main.c        **** 	SREG = saved_sreg;
 529               		.loc 2 232 0
 530               	/* #NOAPP */
 531 0238 8981      		ldd r24,Y+1
 532               	.LVL16:
 533 023a 8FBF      		out __SREG__,r24
 534               	/* epilogue start */
 233:main.c        **** }
 535               		.loc 2 233 0
 536 023c 0F90      		pop __tmp_reg__
 537 023e DF91      		pop r29
 538 0240 CF91      		pop r28
 539 0242 0F91      		pop r16
 540 0244 0895      		ret
 541               		.cfi_endproc
 542               	.LFE22:
 544               	.global	Clock_Init
 546               	Clock_Init:
 547               	.LFB19:
 159:main.c        **** void Clock_Init(void){
 548               		.loc 2 159 0
 549               		.cfi_startproc
 550               	/* prologue: function */
 551               	/* frame size = 0 */
 552               	/* stack size = 0 */
 553               	.L__stack_usage = 0
 160:main.c        **** 	OSC.CTRL |= OSC_RC32MEN_bm;                     // turn on 32MHz internal RC oscillator
 554               		.loc 2 160 0
 555 0246 8091 5000 		lds r24,80
 556 024a 8260      		ori r24,lo8(2)
 557 024c 8093 5000 		sts 80,r24
 558               	.L32:
 161:main.c        **** 	while(!(OSC.STATUS & OSC_RC32MRDY_bm));         // wait for it to be ready
 559               		.loc 2 161 0 discriminator 1
 560 0250 8091 5100 		lds r24,81
 561 0254 81FF      		sbrs r24,1
 562 0256 00C0      		rjmp .L32
 162:main.c        **** 	CCPWrite( &CLK.CTRL, CLK_SCLKSEL_RC32M_gc);     // change from 2MHz to 32MHz
 563               		.loc 2 162 0
 564 0258 61E0      		ldi r22,lo8(1)
 565 025a 80E4      		ldi r24,lo8(64)
 566 025c 90E0      		ldi r25,0
 567 025e 0C94 0000 		jmp CCPWrite
 568               	.LVL17:
 569               		.cfi_endproc
 570               	.LFE19:
 572               		.section	.rodata.str1.1
 573               	.LC1:
 574 0009 5374 6172 		.string	"Starting up!\r"
 574      7469 6E67 
 574      2075 7021 
 574      0D00 
 575               	.LC2:
 576 0017 7072 6573 		.string	"pressing button\r"
 576      7369 6E67 
 576      2062 7574 
 576      746F 6E0D 
 576      00
 577               		.section	.text.startup,"ax",@progbits
 578               	.global	main
 580               	main:
 581               	.LFB17:
  26:main.c        **** int main(void){
 582               		.loc 2 26 0
 583               		.cfi_startproc
 584               	/* prologue: function */
 585               	/* frame size = 0 */
 586               	/* stack size = 0 */
 587               	.L__stack_usage = 0
  29:main.c        ****     Clock_Init();
 588               		.loc 2 29 0
 589 0000 0E94 0000 		call Clock_Init
 590               	.LVL18:
  30:main.c        ****     Debug_Init();
 591               		.loc 2 30 0
 592 0004 0E94 0000 		call Debug_Init
 593               	.LVL19:
  31:main.c        ****     printf("Starting up!\r");
 594               		.loc 2 31 0
 595 0008 80E0      		ldi r24,lo8(.LC1)
 596 000a 90E0      		ldi r25,hi8(.LC1)
 597 000c 9F93      		push r25
 598               	.LCFI28:
 599               		.cfi_def_cfa_offset 3
 600 000e 8F93      		push r24
 601               	.LCFI29:
 602               		.cfi_def_cfa_offset 4
 603 0010 0E94 0000 		call printf
 604               	.LVL20:
  34:main.c        ****     TCC1.PER = 49;
 605               		.loc 2 34 0
 606 0014 81E3      		ldi r24,lo8(49)
 607 0016 90E0      		ldi r25,0
 608 0018 8093 6608 		sts 2150,r24
 609 001c 9093 6708 		sts 2150+1,r25
  35:main.c        ****     TCC1.CTRLA = TC_CLKSEL_DIV64_gc;
 610               		.loc 2 35 0
 611 0020 25E0      		ldi r18,lo8(5)
 612 0022 2093 4008 		sts 2112,r18
  36:main.c        ****     TCC1.INTCTRLA = TC_CCAINTLVL_LO_gc;
 613               		.loc 2 36 0
 614 0026 81E0      		ldi r24,lo8(1)
 615 0028 8093 4608 		sts 2118,r24
  39:main.c        ****     ADCA.CH1.CTRL = ADC_CH_INPUTMODE_SINGLEENDED_gc;    // set input mode
 616               		.loc 2 39 0
 617 002c 8093 2802 		sts 552,r24
  40:main.c        ****     ADCA.CH1.MUXCTRL = ADC_CH_MUXPOS_PIN1_gc;           // set mux to read channel 0, pin A1
 618               		.loc 2 40 0
 619 0030 98E0      		ldi r25,lo8(8)
 620 0032 9093 2902 		sts 553,r25
  43:main.c        ****     ADCA.PRESCALER = (ADCA.PRESCALER & (~ADC_PRESCALER_gm)) | ADC_PRESCALER_DIV16_gc;
 621               		.loc 2 43 0
 622 0036 9091 0402 		lds r25,516
 623 003a 987F      		andi r25,lo8(-8)
 624 003c 9260      		ori r25,lo8(2)
 625 003e 9093 0402 		sts 516,r25
  45:main.c        ****     ADCA.REFCTRL = ADC_REFSEL_INT1V_gc;
 626               		.loc 2 45 0
 627 0042 1092 0202 		sts 514,__zero_reg__
  46:main.c        ****     ADCA.EVCTRL = 0;
 628               		.loc 2 46 0
 629 0046 1092 0302 		sts 515,__zero_reg__
  47:main.c        ****     ADCA.CTRLB = 0;
 630               		.loc 2 47 0
 631 004a 1092 0102 		sts 513,__zero_reg__
  48:main.c        ****     ADCA.CTRLA = ADC_ENABLE_bm;
 632               		.loc 2 48 0
 633 004e 8093 0002 		sts 512,r24
  52:main.c        ****     PORTC.DIRSET = (1 << 0);
 634               		.loc 2 52 0
 635 0052 8093 4106 		sts 1601,r24
  53:main.c        ****     PORTC.OUTCLR = (1 << 0);
 636               		.loc 2 53 0
 637 0056 8093 4606 		sts 1606,r24
  55:main.c        ****     TCC0.CTRLA = 0x05;				//set TC_CLK to CLK/64 (500k)
 638               		.loc 2 55 0
 639 005a 2093 0008 		sts 2048,r18
  56:main.c        ****     TCC0.CTRLB = TC0_CCAEN_bm | TC0_WGMODE0_bm | TC0_WGMODE1_bm;       //Enable OC A,B,C&D.  Set to
 640               		.loc 2 56 0
 641 005e 83E1      		ldi r24,lo8(19)
 642 0060 8093 0108 		sts 2049,r24
  57:main.c        ****     TCC0.PER = 10000;				// (500k / 10k = 50 hz)  (500 bits per ms)
 643               		.loc 2 57 0
 644 0064 80E1      		ldi r24,lo8(16)
 645 0066 97E2      		ldi r25,lo8(39)
 646 0068 8093 2608 		sts 2086,r24
 647 006c 9093 2708 		sts 2086+1,r25
  58:main.c        ****     TCC0.CCA = 750;
 648               		.loc 2 58 0
 649 0070 8EEE      		ldi r24,lo8(-18)
 650 0072 92E0      		ldi r25,lo8(2)
 651 0074 8093 2808 		sts 2088,r24
 652 0078 9093 2908 		sts 2088+1,r25
  61:main.c        ****     currentPORT.DIRSET = currentCS_bm |  currentCLK_bm | currentMOSI_bm;
 653               		.loc 2 61 0
 654 007c 80EB      		ldi r24,lo8(-80)
 655 007e 8093 4106 		sts 1601,r24
  62:main.c        ****     currentPORT.OUTSET = currentCS_bm;
 656               		.loc 2 62 0
 657 0082 80E1      		ldi r24,lo8(16)
 658 0084 8093 4506 		sts 1605,r24
  64:main.c        ****     currentSPI.CTRL = SPI_ENABLE_bm
 659               		.loc 2 64 0
 660 0088 83E5      		ldi r24,lo8(83)
 661 008a 8093 C008 		sts 2240,r24
  72:main.c        ****     outputPORT.DIRSET = usb_pin_bm | cam_pin_bm;
 662               		.loc 2 72 0
 663 008e 83E0      		ldi r24,lo8(3)
 664 0090 8093 6106 		sts 1633,r24
  73:main.c        ****     outputPORT.OUTCLR = usb_pin_bm | cam_pin_bm;
 665               		.loc 2 73 0
 666 0094 8093 6606 		sts 1638,r24
 667               	.LVL21:
 668               	.LBB6:
 669               	.LBB7:
 670               		.file 3 "/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h"
   1:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 152:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 155:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 158:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 159:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 160:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 162:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 671               		.loc 3 163 0
 672 0098 2FEF      		ldi r18,lo8(12799999)
 673 009a 8FE4      		ldi r24,hi8(12799999)
 674 009c 93EC      		ldi r25,hlo8(12799999)
 675 009e 2150      		1: subi r18,1
 676 00a0 8040      		sbci r24,0
 677 00a2 9040      		sbci r25,0
 678 00a4 01F4      		brne 1b
 679 00a6 00C0      		rjmp .
 680 00a8 0000      		nop
 681               	.LBE7:
 682               	.LBE6:
  77:main.c        ****     Interrupts_Init();
 683               		.loc 2 77 0
 684 00aa 0E94 0000 		call Interrupts_Init
 685               	.LVL22:
 686 00ae 0F90      		pop __tmp_reg__
 687 00b0 0F90      		pop __tmp_reg__
 688               	.LCFI30:
 689               		.cfi_def_cfa_offset 2
  98:main.c        ****                     outputPORT.OUTCLR = cam_pin_bm;
 690               		.loc 2 98 0
 691 00b2 02E0      		ldi r16,lo8(2)
 108:main.c        ****                     runServo = true;
 692               		.loc 2 108 0
 693 00b4 11E0      		ldi r17,lo8(1)
 109:main.c        ****                     printf("pressing button\r");
 694               		.loc 2 109 0
 695 00b6 C0E0      		ldi r28,lo8(.LC2)
 696 00b8 D0E0      		ldi r29,hi8(.LC2)
 697               	.L36:
 698               	.LVL23:
 699               	.LBB8:
 700               	.LBB9:
 701               		.loc 3 163 0
 702 00ba 2FEF      		ldi r18,lo8(63999)
 703 00bc 89EF      		ldi r24,hi8(63999)
 704 00be 90E0      		ldi r25,hlo8(63999)
 705 00c0 2150      		1: subi r18,1
 706 00c2 8040      		sbci r24,0
 707 00c4 9040      		sbci r25,0
 708 00c6 01F4      		brne 1b
 709 00c8 00C0      		rjmp .
 710 00ca 0000      		nop
 711               	.LBE9:
 712               	.LBE8:
  91:main.c        ****         if(Debug_CharReadyToRead()){
 713               		.loc 2 91 0
 714 00cc 0E94 0000 		call Debug_CharReadyToRead
 715               	.LVL24:
 716 00d0 8823      		tst r24
 717 00d2 01F0      		breq .L36
  92:main.c        ****             command = Debug_GetByte(false);
 718               		.loc 2 92 0
 719 00d4 80E0      		ldi r24,0
 720 00d6 0E94 0000 		call Debug_GetByte
 721               	.LVL25:
 722 00da 8093 0000 		sts command,r24
  93:main.c        ****             switch (command) {
 723               		.loc 2 93 0
 724 00de 8336      		cpi r24,lo8(99)
 725 00e0 01F0      		breq .L38
 726 00e2 00F4      		brsh .L39
 727 00e4 8334      		cpi r24,lo8(67)
 728 00e6 01F0      		breq .L40
 729 00e8 8535      		cpi r24,lo8(85)
 730 00ea 01F4      		brne .L36
 101:main.c        ****                     outputPORT.OUTSET = usb_pin_bm;
 731               		.loc 2 101 0
 732 00ec 1093 6506 		sts 1637,r17
 102:main.c        ****                     break;
 733               		.loc 2 102 0
 734 00f0 00C0      		rjmp .L36
 735               	.L39:
  93:main.c        ****             switch (command) {
 736               		.loc 2 93 0
 737 00f2 8337      		cpi r24,lo8(115)
 738 00f4 01F0      		breq .L42
 739 00f6 8537      		cpi r24,lo8(117)
 740 00f8 01F4      		brne .L36
 104:main.c        ****                     outputPORT.OUTCLR = usb_pin_bm;
 741               		.loc 2 104 0
 742 00fa 1093 6606 		sts 1638,r17
 105:main.c        ****                     break;
 743               		.loc 2 105 0
 744 00fe 00C0      		rjmp .L36
 745               	.L40:
  95:main.c        ****                     outputPORT.OUTSET = cam_pin_bm;
 746               		.loc 2 95 0
 747 0100 0093 6506 		sts 1637,r16
  96:main.c        ****                     break;
 748               		.loc 2 96 0
 749 0104 00C0      		rjmp .L36
 750               	.L38:
  98:main.c        ****                     outputPORT.OUTCLR = cam_pin_bm;
 751               		.loc 2 98 0
 752 0106 0093 6606 		sts 1638,r16
  99:main.c        ****                     break;
 753               		.loc 2 99 0
 754 010a 00C0      		rjmp .L36
 755               	.L42:
 107:main.c        ****                     currentCapCounter = 0;
 756               		.loc 2 107 0
 757 010c 1092 0000 		sts currentCapCounter,__zero_reg__
 108:main.c        ****                     runServo = true;
 758               		.loc 2 108 0
 759 0110 1093 0000 		sts runServo,r17
 109:main.c        ****                     printf("pressing button\r");
 760               		.loc 2 109 0
 761 0114 DF93      		push r29
 762               	.LCFI31:
 763               		.cfi_def_cfa_offset 3
 764 0116 CF93      		push r28
 765               	.LCFI32:
 766               		.cfi_def_cfa_offset 4
 767 0118 0E94 0000 		call printf
 768               	.LVL26:
 110:main.c        ****                     break;
 769               		.loc 2 110 0
 770 011c 0F90      		pop __tmp_reg__
 771 011e 0F90      		pop __tmp_reg__
 772               	.LCFI33:
 773               		.cfi_def_cfa_offset 2
 774 0120 00C0      		rjmp .L36
 775               		.cfi_endproc
 776               	.LFE17:
 778               		.comm	runServo,1,1
 779               	.global	currentCapCounter
 780               		.section .bss
 783               	currentCapCounter:
 784 0000 00        		.zero	1
 785               	.global	servoSpeedCounter
 788               	servoSpeedCounter:
 789 0001 0000      		.zero	2
 790               		.comm	servoCurrent,2,1
 791               	.global	command
 794               	command:
 795 0003 00        		.zero	1
 796               		.data
 799               	mystdout:
 800 0000 0000 00   		.zero	3
 801 0003 02        		.byte	2
 802 0004 0000 0000 		.zero	4
 803 0008 0000      		.word	gs(Debug_SendByte)
 804 000a 0000      		.word	0
 805 000c 0000      		.word	0
 806               	.global	Debug_writeLocation
 807               		.section .bss
 810               	Debug_writeLocation:
 811 0004 0000      		.zero	2
 812               	.global	Debug_readLocation
 815               	Debug_readLocation:
 816 0006 0000      		.zero	2
 817               		.comm	DebugBuffer,100,1
 818               		.text
 819               	.Letext0:
 820               		.file 4 "/usr/local/CrossPack-AVR-20131216/avr/include/stdint.h"
 821               		.file 5 "/usr/local/CrossPack-AVR-20131216/avr/include/avr/iox32a4.h"
 822               		.file 6 "/usr/local/CrossPack-AVR-20131216/avr/include/stdio.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
/var/folders/8j/r8y_blqj5w10gdv_pjjxskz40000gn/T//ccaJSJbk.s:2      *ABS*:0000003e __SP_H__
/var/folders/8j/r8y_blqj5w10gdv_pjjxskz40000gn/T//ccaJSJbk.s:3      *ABS*:0000003d __SP_L__
/var/folders/8j/r8y_blqj5w10gdv_pjjxskz40000gn/T//ccaJSJbk.s:4      *ABS*:0000003f __SREG__
/var/folders/8j/r8y_blqj5w10gdv_pjjxskz40000gn/T//ccaJSJbk.s:5      *ABS*:00000034 __CCP__
/var/folders/8j/r8y_blqj5w10gdv_pjjxskz40000gn/T//ccaJSJbk.s:6      *ABS*:00000000 __tmp_reg__
/var/folders/8j/r8y_blqj5w10gdv_pjjxskz40000gn/T//ccaJSJbk.s:7      *ABS*:00000001 __zero_reg__
/var/folders/8j/r8y_blqj5w10gdv_pjjxskz40000gn/T//ccaJSJbk.s:13     .text:00000000 Debug_SendByte
/var/folders/8j/r8y_blqj5w10gdv_pjjxskz40000gn/T//ccaJSJbk.s:36     .text:0000000e Debug_Init
/var/folders/8j/r8y_blqj5w10gdv_pjjxskz40000gn/T//ccaJSJbk.s:799    .data:00000000 mystdout
/var/folders/8j/r8y_blqj5w10gdv_pjjxskz40000gn/T//ccaJSJbk.s:85     .text:00000048 Debug_CharReadyToRead
/var/folders/8j/r8y_blqj5w10gdv_pjjxskz40000gn/T//ccaJSJbk.s:810    .bss:00000004 Debug_writeLocation
/var/folders/8j/r8y_blqj5w10gdv_pjjxskz40000gn/T//ccaJSJbk.s:815    .bss:00000006 Debug_readLocation
/var/folders/8j/r8y_blqj5w10gdv_pjjxskz40000gn/T//ccaJSJbk.s:111    .text:00000064 Debug_GetByte
                            *COM*:00000064 DebugBuffer
/var/folders/8j/r8y_blqj5w10gdv_pjjxskz40000gn/T//ccaJSJbk.s:166    .text:000000ae __vector_58
/var/folders/8j/r8y_blqj5w10gdv_pjjxskz40000gn/T//ccaJSJbk.s:244    .text:0000010c __vector_20
                            *COM*:00000001 runServo
/var/folders/8j/r8y_blqj5w10gdv_pjjxskz40000gn/T//ccaJSJbk.s:788    .bss:00000001 servoSpeedCounter
/var/folders/8j/r8y_blqj5w10gdv_pjjxskz40000gn/T//ccaJSJbk.s:391    .text:000001c0 Interrupts_Init
/var/folders/8j/r8y_blqj5w10gdv_pjjxskz40000gn/T//ccaJSJbk.s:417    .text:000001ce Current_Read
/var/folders/8j/r8y_blqj5w10gdv_pjjxskz40000gn/T//ccaJSJbk.s:480    .text:0000021c CCPWrite
/var/folders/8j/r8y_blqj5w10gdv_pjjxskz40000gn/T//ccaJSJbk.s:546    .text:00000246 Clock_Init
/var/folders/8j/r8y_blqj5w10gdv_pjjxskz40000gn/T//ccaJSJbk.s:580    .text.startup:00000000 main
/var/folders/8j/r8y_blqj5w10gdv_pjjxskz40000gn/T//ccaJSJbk.s:794    .bss:00000003 command
/var/folders/8j/r8y_blqj5w10gdv_pjjxskz40000gn/T//ccaJSJbk.s:783    .bss:00000000 currentCapCounter
                            *COM*:00000002 servoCurrent

UNDEFINED SYMBOLS
__iob
printf
__do_copy_data
__do_clear_bss
